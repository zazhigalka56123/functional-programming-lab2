# Лабораторная работа №2

**Выполнил:** Пасечник Иван Андреевич  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure  
**Вариант:** pre-dict

---

## Тема

**Реализация структуры данных Prefix Tree на основе Dictionary**

---

## Цель работы

Закрепить навыки функционального программирования на языке **Clojure**, реализовав неизменяемую полиморфную структуру данных с поддержкой:

- добавления и удаления элементов;
- фильтрации (`filter`);
- отображения (`map`);
- свёрток (`foldl` и `foldr`);
- свойств моноида (ассоциативность и нейтральный элемент);
- тестирования (unit и property-based).

---

## Основные функции API

### Базовые операции

| Функция | Назначение |
|---------|-----------|
| `empty-tree` | Создать пустое префиксное дерево |
| `add` | Добавить слово в дерево |
| `tree-contains?` | Проверить наличие слова |
| `tree-remove` | Удалить слово из дерева |
| `tree->seq` | Получить последовательность всех слов (лексикографический порядок) |
| `mappend` | Объединение двух деревьев (операция моноида) |
| `tree-equal?` | Проверка равенства деревьев |

### Стандартные функции высшего порядка

Благодаря реализации протокола `Seqable`, префиксное дерево поддерживает стандартные функции Clojure:

| Функция | Назначение | Пример |
|---------|-----------|--------|
| `map` | Отображение функции на все слова | `(map clojure.string/upper-case tree)` |
| `filter` | Фильтрация слов по предикату | `(filter #(> (count %) 3) tree)` |
| `reduce` | Левая свёртка | `(reduce str tree)` |
| `seq` | Преобразование в последовательность | `(seq tree)` |
| `count` | Количество слов | `(count tree)` |
| `get` | Проверка наличия слова | `(get tree "word")` |
| `contains?` | Проверка наличия слова | `(contains? tree "word")` |
| `conj` | Добавление слова | `(conj tree "word")` |
| `assoc` | Добавление слова | `(assoc tree "word" true)` |

---

## Реализация

### Ключевые особенности

- Используется **рекурсивная структура вложенных map (dictionary)** для хранения префиксов.
- Все структуры **иммутабельны**: любая операция возвращает новое дерево.
- Поддержан **моноид**:
  - Нейтральный элемент — пустое дерево.
  - Операция — `mappend` ([`impl.clj:103-112`](src/prefix_tree/impl.clj#L103-L112)).
  - Ассоциативность проверяется property-тестами.
- **Интеграция со стандартной библиотекой Clojure** через реализацию протоколов коллекций ([`impl.clj:30-69`](src/prefix_tree/impl.clj#L30-L69)).

### Структура данных

Префиксное дерево представлено как вложенный dictionary (Clojure map), где:
- Ключи — символы слова
- Значения — поддеревья (рекурсивно)
- Специальный ключ `:end?` — маркер конца слова

Пример структуры для слов "tea", "ten":
```clojure
{\t {\e {\a {:end? true}
          \n {:end? true}}}}
```

Реализация добавления ([`impl.clj:10-11`](src/prefix_tree/impl.clj#L10-L11)):
```clojure
(tree-add [_ word]
  (PrefixTree. (assoc-in data (conj (vec word) :end?) true)))
```

---

## Интеграция со стандартной библиотекой Clojure

Префиксное дерево реализует протоколы стандартной библиотеки коллекций Clojure ([`impl.clj:30-69`](src/prefix_tree/impl.clj#L30-L69)), что позволяет использовать его как обычную коллекцию:

### Реализованные протоколы

| Протокол | Методы | Описание | Доступные функции |
|----------|--------|----------|-------------------|
| `Seqable` | `seq` | Преобразование в последовательность слов | `seq`, `map`, `filter`, `reduce`, `for`, `doseq` и др. |
| `Counted` | `count` | Получение количества слов в дереве | `count`, `empty?` |
| `IPersistentCollection` | `cons`, `empty`, `equiv` | Базовые операции коллекций | `conj`, `empty`, `=` |
| `ILookup` | `valAt` | Поиск слова через `get` | `get`, `get-in` |
| `Associative` | `assoc`, `containsKey`, `entryAt` | Ассоциативные операции | `assoc`, `contains?`, `find` |
| `IFn` | `invoke` | Вызов дерева как функции для проверки наличия слова | `(tree "word")` |

### Примеры использования

```clojure
(def tree (-> empty-tree
              (add "cat")
              (add "car")
              (add "card")))

;; Использование как последовательность
(seq tree)           ; => ("car" "card" "cat")
(count tree)         ; => 3

;; Использование как lookup-структура
(get tree "cat")     ; => true
(get tree "dog" :not-found) ; => :not-found

;; Использование как функция
(tree "cat")         ; => true
(tree "dog")         ; => false

;; Ассоциативные операции
(contains? tree "car")  ; => true
(assoc tree "dog" true) ; => дерево с добавленным "dog"
(conj tree "dog")       ; => дерево с добавленным "dog"

;; Стандартные функции коллекций
(empty tree)         ; => пустое дерево
(= tree tree)        ; => true (через equiv)

;; Функции высшего порядка (благодаря Seqable)
;; Map - преобразование всех слов
(map clojure.string/upper-case tree)  ; => ("CAR" "CARD" "CAT")

;; Filter - фильтрация слов
(filter #(> (count %) 3) tree)        ; => ("card")

;; Reduce - свёртка (левая)
(reduce str tree)                      ; => "carcard cat"
(reduce (fn [acc word] (+ acc (count word))) 0 tree)  ; => 10

;; Reduce с начальным значением
(reduce conj [] tree)                  ; => ["car" "card" "cat"]
```

---

## Тестирование

### Unit-тесты ([`test/prefix_tree/unit_test.clj`](test/prefix_tree/unit_test.clj))

Покрывают:
- корректность `add`, `tree-remove`, `tree-contains?` ([`unit_test.clj:5-35`](test/prefix_tree/unit_test.clj#L5-L35));
- свойства неизменяемости;
- сравнение и объединение деревьев ([`unit_test.clj:62-72`](test/prefix_tree/unit_test.clj#L62-L72));
- преобразование в последовательность ([`unit_test.clj:37-42`](test/prefix_tree/unit_test.clj#L37-L42)).

---

### Property-based тестирование ([`test/prefix_tree/property_test.clj`](test/prefix_tree/property_test.clj))

Используется библиотека `clojure.test.check`. Проверяются следующие свойства:

1. **Моноид**: нейтральный элемент и ассоциативность `mappend`
2. **Добавление**: идемпотентность и корректность `tree-contains?`
3. **Удаление**: удалённое слово отсутствует в дереве
4. **Последовательность**: лексикографический порядок слов
5. **Равенство**: рефлексивность и симметричность
6. **Объединение**: коммутативность для множеств слов

### Кастомные генераторы ([`test/prefix_tree/generators.clj`](test/prefix_tree/generators.clj))

Для property-based тестов реализованы специальные генераторы:
- `gen-word` — случайные слова
- `gen-tree` — случайные префиксные деревья
- `gen-tree-and-existing-word` — пары [дерево, существующее слово]

---

## Выводы

В ходе лабораторной работы я:

- реализовал полиморфную, неизменяемую структуру данных `Prefix Tree` (префиксное дерево) на основе dictionary;
- интегрировал структуру данных со **стандартными протоколами коллекций Clojure** (`Seqable`, `Counted`, `IPersistentCollection`, `ILookup`, `Associative`, `IFn`), что позволяет использовать префиксное дерево как обычную коллекцию с поддержкой стандартных функций (`seq`, `count`, `get`, `contains?`, `conj`, `assoc` и др.);
- применил **property-based тестирование** для проверки алгебраических свойств;
- закрепил принципы **функционального программирования**: иммутабельность, рекурсия, композиция функций;
- реализовал эффективное сравнение деревьев без наивного приведения к спискам;
- использовал протоколы Clojure для достижения полиморфизма и интеграции со стандартной библиотекой.
