# Лабораторная работа №2

**Выполнил:** Пасечник Иван Андреевич  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure  
**Вариант:** pre-dict

---

## Тема

**Реализация структуры данных Prefix Tree на основе Dictionary**

---

## Цель работы

Закрепить навыки функционального программирования на языке **Clojure**, реализовав неизменяемую полиморфную структуру данных с поддержкой:

- добавления и удаления элементов;
- фильтрации (`filter`);
- отображения (`map`);
- свёрток (`foldl` и `foldr`);
- свойств моноида (ассоциативность и нейтральный элемент);
- тестирования (unit и property-based).

---

## Основные функции API

| Функция | Назначение |
|---------|-----------|
| `empty-tree` | Создать пустое префиксное дерево |
| `add` | Добавить слово в дерево |
| `tree-contains?` | Проверить наличие слова |
| `tree-remove` | Удалить слово из дерева |
| `tree->seq` | Получить последовательность всех слов (лексикографический порядок) |
| `map-tree` | Отобразить функцию на все слова |
| `filter-tree` | Отфильтровать слова по предикату |
| `reduce-left` | Левая свёртка |
| `reduce-right` | Правая свёртка |
| `mappend` | Объединение двух деревьев (операция моноида) |
| `tree-equal?` | Проверка равенства деревьев |

---

## Реализация

### Ключевые особенности

- Используется **рекурсивная структура вложенных map (dictionary)** для хранения префиксов.
- Все структуры **иммутабельны**: любая операция возвращает новое дерево.
- Поддержан **моноид**:
  - Нейтральный элемент — пустое дерево.
  - Операция — `mappend` ([`impl.clj:82-91`](src/prefix_tree/impl.clj#L82-L91)).
  - Ассоциативность проверяется property-тестами.

### Структура данных

Префиксное дерево представлено как вложенный dictionary (Clojure map), где:
- Ключи — символы слова
- Значения — поддеревья (рекурсивно)
- Специальный ключ `:end?` — маркер конца слова

Пример структуры для слов "tea", "ten":
```clojure
{\t {\e {\a {:end? true}
          \n {:end? true}}}}
```

Реализация добавления ([`impl.clj:9-10`](src/prefix_tree/impl.clj#L9-L10)):
```clojure
(tree-add [this word]
  (PrefixTree. (assoc-in data (conj (vec word) :end?) true)))
```

---

## Тестирование

### Unit-тесты ([`test/prefix_tree/unit_test.clj`](test/prefix_tree/unit_test.clj))

Покрывают:
- корректность `add`, `tree-remove`, `tree-contains?` ([`unit_test.clj:5-35`](test/prefix_tree/unit_test.clj#L5-L35));
- свойства неизменяемости;
- работу фильтрации, отображения, свёрток ([`unit_test.clj:44-59`](test/prefix_tree/unit_test.clj#L44-L59));
- сравнение и объединение деревьев ([`unit_test.clj:62-72`](test/prefix_tree/unit_test.clj#L62-L72));
- преобразование в последовательность ([`unit_test.clj:37-42`](test/prefix_tree/unit_test.clj#L37-L42)).

---

### Property-based тестирование ([`test/prefix_tree/property_test.clj`](test/prefix_tree/property_test.clj))

Используется библиотека `clojure.test.check`. Проверяются следующие свойства:

1. **Моноид**: нейтральный элемент и ассоциативность `mappend`
2. **Добавление**: идемпотентность и корректность `tree-contains?`
3. **Удаление**: удалённое слово отсутствует в дереве
4. **Последовательность**: лексикографический порядок слов
5. **Map и filter**: сохранение размера и корректность предиката
6. **Свёртки**: эквивалентность `reduce-left` стандартному `reduce`
7. **Равенство**: рефлексивность и симметричность
8. **Объединение**: коммутативность для множеств слов

### Кастомные генераторы ([`test/prefix_tree/generators.clj`](test/prefix_tree/generators.clj))

Для property-based тестов реализованы специальные генераторы:
- `gen-word` — случайные слова
- `gen-tree` — случайные префиксные деревья
- `gen-tree-and-existing-word` — пары [дерево, существующее слово]

---

## Выводы

В ходе лабораторной работы я:

- реализовал полиморфную, неизменяемую структуру данных `Prefix Tree` (префиксное дерево) на основе dictionary;
- применил **property-based тестирование** для проверки алгебраических свойств;
- закрепил принципы **функционального программирования**: иммутабельность, рекурсия, композиция функций, свёртки и отображения;
- реализовал эффективное сравнение деревьев без наивного приведения к спискам;
- использовал протоколы Clojure для достижения полиморфизма.
