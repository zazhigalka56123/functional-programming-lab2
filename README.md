# Лабораторная работа №2

**Выполнил:** Пасечник Иван Андреевич  
**Группа:** P3331  
**Преподаватель:** Пенской Александр Владимирович  
**Язык:** Clojure  
**Вариант:** pre-dict

---

## Тема

**Реализация структуры данных Prefix Tree на основе Dictionary**

---

## Цель работы

Закрепить навыки функционального программирования на языке **Clojure**, реализовав неизменяемую полиморфную структуру данных с поддержкой:

- добавления и удаления элементов;
- фильтрации (`filter`);
- отображения (`map`);
- свёрток (`foldl` и `foldr`);
- свойств моноида (ассоциативность и нейтральный элемент);
- разделения интерфейса и реализации (Clean Architecture);
- тестирования (unit и property-based).

---

## Основные функции API

| Функция | Назначение |
|---------|-----------|
| `empty-tree` | Создать пустое префиксное дерево |
| `add` | Добавить слово в дерево |
| `tree-contains?` | Проверить наличие слова |
| `tree-remove` | Удалить слово из дерева |
| `tree->seq` | Получить последовательность всех слов (лексикографический порядок) |
| `map-tree` | Отобразить функцию на все слова |
| `filter-tree` | Отфильтровать слова по предикату |
| `reduce-left` | Левая свёртка |
| `reduce-right` | Правая свёртка |
| `mappend` | Объединение двух деревьев (операция моноида) |
| `tree-equal?` | Проверка равенства деревьев |

---

## Реализация

### Ключевые особенности

- Используется **рекурсивная структура вложенных map (dictionary)** для хранения префиксов.
- Все структуры **иммутабельны**: любая операция возвращает новое дерево.
- Поддержан **моноид**:
  - Нейтральный элемент — пустое дерево.
  - Операция — `mappend` ([`impl.clj:82-91`](src/prefix_tree/impl.clj#L82-L91)).
  - Ассоциативность проверяется property-тестами.

### Структура данных

Префиксное дерево представлено как вложенный dictionary (Clojure map), где:
- Ключи — символы слова
- Значения — поддеревья (рекурсивно)
- Специальный ключ `:end?` — маркер конца слова

Пример структуры для слов "tea", "ten":
```clojure
{\t {\e {\a {:end? true}
          \n {:end? true}}}}
```

Реализация добавления ([`impl.clj:9-10`](src/prefix_tree/impl.clj#L9-L10)):
```clojure
(tree-add [this word]
  (PrefixTree. (assoc-in data (conj (vec word) :end?) true)))
```

---

## Тестирование

### Unit-тесты ([`test/prefix_tree/unit_test.clj`](test/prefix_tree/unit_test.clj))

Покрывают:
- корректность `add`, `tree-remove`, `tree-contains?` ([`unit_test.clj:5-35`](test/prefix_tree/unit_test.clj#L5-L35));
- свойства неизменяемости;
- работу фильтрации, отображения, свёрток ([`unit_test.clj:44-59`](test/prefix_tree/unit_test.clj#L44-L59));
- сравнение и объединение деревьев ([`unit_test.clj:62-72`](test/prefix_tree/unit_test.clj#L62-L72));
- преобразование в последовательность ([`unit_test.clj:37-42`](test/prefix_tree/unit_test.clj#L37-L42)).

---

### Property-based тестирование ([`test/prefix_tree/property_test.clj`](test/prefix_tree/property_test.clj))

Используется библиотека `clojure.test.check`.  
Проверяются следующие свойства:

1. **Идентичность моноида** ([`property_test.clj:11-16`](test/prefix_tree/property_test.clj#L11-L16)): `(mappend t empty-tree) == t`
2. **Ассоциативность моноида** ([`property_test.clj:18-26`](test/prefix_tree/property_test.clj#L18-L26)): `(mappend (mappend a b) c) == (mappend a (mappend b c))`
3. **Идемпотентность добавления** ([`property_test.clj:41-47`](test/prefix_tree/property_test.clj#L41-L47)): повторное добавление слова не меняет дерево
4. **Корректность удаления** ([`property_test.clj:36-39`](test/prefix_tree/property_test.clj#L36-L39)): удалённое слово не содержится в дереве
5. **Сохранение порядка** ([`property_test.clj:64-69`](test/prefix_tree/property_test.clj#L64-L69)): `tree->seq` возвращает слова в лексикографическом порядке
6. **Корректность map** ([`property_test.clj:76-81`](test/prefix_tree/property_test.clj#L76-L81)): `map-tree` сохраняет количество элементов
7. **Корректность filter** ([`property_test.clj:90-96`](test/prefix_tree/property_test.clj#L90-L96)): все элементы после фильтрации удовлетворяют предикату
8. **Эквивалентность свёрток** ([`property_test.clj:99-106`](test/prefix_tree/property_test.clj#L99-L106)): `reduce-left` эквивалентен стандартному `reduce`
9. **Рефлексивность равенства** ([`property_test.clj:116-118`](test/prefix_tree/property_test.clj#L116-L118)): дерево равно самому себе
10. **Коммутативность merge** ([`property_test.clj:144-151`](test/prefix_tree/property_test.clj#L144-L151)): объединение деревьев коммутативно для множеств

### Кастомные генераторы ([`test/prefix_tree/generators.clj`](test/prefix_tree/generators.clj))

Для property-based тестов реализованы специальные генераторы:
- `gen-word` — случайные слова
- `gen-tree` — случайные префиксные деревья
- `gen-tree-and-existing-word` — пары [дерево, существующее слово]

---

## Выводы

В ходе лабораторной работы я:

- реализовал полиморфную, неизменяемую структуру данных `Prefix Tree` (префиксное дерево) на основе dictionary;
- применил **property-based тестирование** для проверки алгебраических свойств;
- закрепил принципы **функционального программирования**: иммутабельность, рекурсия, композиция функций, свёртки и отображения;
- реализовал эффективное сравнение деревьев без наивного приведения к спискам;
- использовал протоколы Clojure для достижения полиморфизма.
